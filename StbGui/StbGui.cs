#pragma warning disable IDE1006 // Naming Styles

namespace StbSharp;

using System;
using widget_id = int;
using widget_hash = int;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.ComponentModel;

// Reference:
// - https://www.rfleury.com/p/posts-table-of-contents
// - https://www.rfleury.com/p/ui-part-1-the-interaction-medium
// - https://www.rfleury.com/p/ui-part-2-build-it-every-frame-immediate
// - https://www.rfleury.com/p/ui-part-3-the-widget-building-language
// - https://www.youtube.com/watch?v=-z8_F9ozERc
// - https://asawicki.info/Download/Productions/Lectures/Immediate%20Mode%20GUI.pdf

public class StbGui
{
    public const widget_id STBG_WIDGET_ID_NULL = 0;

    public enum STBG_SIZE_KIND
    {
        NULL,
        PIXELS,
        TEXT_CONTENT,
        PERCENT_OF_PARENT,
        CHILDREN_SUM,
    };

    public enum STBG_AXIS
    {
        X,
        Y,
    }

    public struct stbg_size
    {
        public STBG_SIZE_KIND kind;
        public float value;
        public float strictness;
    }

    public struct stbg_widget_hierarchy
    {
        // Parent id
        public widget_id parent_id;

        // Siblings ids (widgets with same parent_id)
        public widget_id next_sibling_id; // points to next free widget id if widget not used
        public widget_id prev_sibling_id;

        // Children ids (widgets that have us in their parent_id)
        public widget_id first_children_id;
        public widget_id last_children_id;
    }

    public struct stbg_rect
    {
        // Top left corner
        public float x0;
        public float y0;

        // Bottom right corner
        public float x1;
        public float y1;
    }

    public struct stbg_widget_size
    {
        public stbg_size x;
        public stbg_size y;
    }

    public struct stbg_widget_computed_bounds
    {
        public float relative_x;
        public float relative_y;
        public float size_x;
        public float size_y;

        public stbg_rect global_rect;
    }

    public enum STBG_WIDGET_TYPE
    {
        NONE,
        ROOT,
        BUTTON,
    }

    [Flags]
    public enum STBG_WIDGET_FLAGS
    {
        NONE = 0,
        USED = 1 << 0,
    }

    public struct stbg_widget_hash_chain
    {
        public widget_id next_same_bucket;
        public widget_id prev_same_bucket;
    }

    public struct stbg_widget
    {
        // This widget id (it's also the index in the main widgets array)
        public widget_id id;

        // This widget hash (generated by combining the unique identifier in the context of the widget + the hash of the parent)
        public widget_hash hash;

        // Last frame in which this widget was used
        public int last_used_in_frame;

        // Type of widget
        public STBG_WIDGET_TYPE type;

        public STBG_WIDGET_FLAGS flags;

        public stbg_widget_hierarchy hierarchy;

        public stbg_widget_size size;

        public stbg_widget_computed_bounds computed_bounds;

        public stbg_widget_hash_chain hash_chain;
    }

    public struct stbg_hash_entry
    {
        public widget_id first_widget_in_bucket;
    }

    public struct stbg_context_frame_stats
    {
        public int new_widgets;
        public int reused_widgets;
        public int destroyed_widgets;
        public int duplicated_widgets_ids;
    }

    public struct stbg_context
    {
        public stbg_widget[] widgets;

        public stbg_hash_entry[] hash_table;

        public widget_id first_free_widget_id;

        public bool inside_frame;

        public int current_frame;

        public widget_id current_widget_id;

        public widget_id root_widget_id;

        public stbg_context_frame_stats frame_stats;

        public stbg_context_frame_stats prev_frame_stats;

        public stbg_init_options init_options;
    }

    public enum STBG_DUP_ID_BEHAVIOUR
    {
        /// <summary>
        /// Asserts in DEBUG builds, does nothing in RELEASE builds
        /// </summary>
        ASSERT,
        /// <summary>
        /// Throws an exception in both DEBUG and RELEASE builds
        /// </summary>
        EXCEPTION,
        /// <summary>
        /// Logs an error message in the error console in DEBUG and RELEASE builds
        /// </summary>
        CONSOLE,
        /// <summary>
        /// Does nothing in DEBUG and RELEASE builds
        /// </summary>
        NONE,
    }

    public struct stbg_init_options
    {
        /// <summary>
        /// Max number of widgets, defaults to DEFAULT_MAX_WIDGETS
        /// </summary>
        public int max_widgets;


        /// <summary>
        /// Behaviour when a duplicated widget identifier is found, defaults to ASSERT
        /// </summary>
        public STBG_DUP_ID_BEHAVIOUR duplicated_widget_identifier_behaviour;
    }

    static private stbg_context context;

    /// <summary>
    /// Returns a reference to the current context
    /// </summary>
    /// <returns>Context</returns>
    public static ref stbg_context stbg_get_context() => ref context;

    /// <summary>
    /// Init GUI library.
    /// It initializes the shared context used by all the other functions.
    /// </summary>
    static public void stbg_init(stbg_init_options options)
    {
        context = new stbg_context();

        stbg_init_context(ref context, options);
    }

    private const int DEFAULT_MAX_WIDGETS = 32767;

    private static void stbg_init_context(ref stbg_context context, stbg_init_options options)
    {
        if (options.max_widgets == 0)
            options.max_widgets = DEFAULT_MAX_WIDGETS;

        var widgets = new stbg_widget[options.max_widgets];
        var hashTable = new stbg_hash_entry[widgets.Length];

        // init ids and flags
        for (int i = 0; i < widgets.Length; i++)
        {
            ref var widget = ref widgets[i];
            widget.id = i;
        }

        // init chain of free widgets
        // we start from the index 1, because we want to reserve the index 0 as "null"
        for (int i = 1; i < widgets.Length - 1; i++)
        {
            ref var widget = ref widgets[i];
            ref var nextWidget = ref widgets[i + 1];

            widget.hierarchy.next_sibling_id = nextWidget.id;
        }

        context.widgets = widgets;
        context.hash_table = hashTable;
        context.first_free_widget_id = context.widgets[1].id;
        context.init_options = options;
    }

    /// <summary>
    /// Destroy GUI library.
    /// </summary>
    public static void stbg_destroy()
    {
        context = default;
    }

    /// <summary>
    /// Starts a new frame
    /// </summary>
    public static void stbg_begin_frame()
    {
        Debug.Assert(!context.inside_frame);
        context.inside_frame = true;
        context.current_widget_id = STBG_WIDGET_ID_NULL;
        context.current_frame++;
        context.prev_frame_stats = context.frame_stats;
        context.frame_stats = new stbg_context_frame_stats();

        ref var root = ref add_widget(STBG_WIDGET_TYPE.ROOT, "root");

        context.current_widget_id = root.id;
        context.root_widget_id = root.id;
    }

    /// <summary>
    /// Ends the current frame
    /// </summary>
    public static void stbg_end_frame()
    {
        Debug.Assert(context.inside_frame, "Not inside a frame");
        Debug.Assert(context.current_widget_id == context.root_widget_id, "Unbalanced begin() / end() calls");

        context.inside_frame = false;
        context.current_widget_id = STBG_WIDGET_ID_NULL;

        // If we didn't reuse the same amount of widgets that existed in the last frame, then some widgets need to be destroyed!
        if (context.prev_frame_stats.new_widgets + context.prev_frame_stats.reused_widgets > context.frame_stats.reused_widgets)
        {
            int amount_to_destroy = (context.prev_frame_stats.new_widgets + context.prev_frame_stats.reused_widgets) - context.frame_stats.reused_widgets;
            stbg__destroy_unused_widgets(amount_to_destroy);
        }
    }

    private static void stbg__destroy_unused_widgets(int amount_to_destroy)
    {
        var widgets = context.widgets;

        for (int i = 0; i < widgets.Length && amount_to_destroy > 0; i++)
        {
            if ((widgets[i].flags & STBG_WIDGET_FLAGS.USED) != 0 && widgets[i].last_used_in_frame != context.current_frame)
            {
                stbg__remove_widget(ref widgets[i]);
                amount_to_destroy--;
            }
        }
    }

    /// <summary>
    /// Returns a reference to a widget given a widget id
    /// </summary>
    /// <param name="id">Widget id</param>
    /// <returns>Widget reference</returns>
    public static ref stbg_widget stbg_get_widget_by_id(widget_id id)
    {
        return ref context.widgets[id];
    }

    public static bool stbg_button(string label)
    {
        add_widget(STBG_WIDGET_TYPE.BUTTON, label);

        return false;
    }

    private static ref stbg_widget add_widget(STBG_WIDGET_TYPE type, string identifier)
    {
        ref var widget = ref stbg__add_widget(stbg__calculate_hash(type, identifier));

        widget.type = type;

        return ref widget;
    }

    private static ref stbg_widget stbg__add_widget(widget_hash hash)
    {
        Debug.Assert(context.inside_frame);
        Debug.Assert(context.first_free_widget_id != STBG_WIDGET_ID_NULL);

        ref var widget =
            ref (stbg__find_widget_by_hash(hash, out var existingWidgetId) ?
                ref stbg_get_widget_by_id(existingWidgetId) :
                ref stbg_get_widget_by_id(context.first_free_widget_id));

        if ((widget.flags & STBG_WIDGET_FLAGS.USED) == 0)
        {
            // New widget!
            context.frame_stats.new_widgets++;

            // Mark as used
            widget.flags |= STBG_WIDGET_FLAGS.USED;

            // Reset dynamic properties
            widget.size = new stbg_widget_size();
            widget.computed_bounds = new stbg_widget_computed_bounds();

            // Update the next free widget id        
            context.first_free_widget_id = widget.hierarchy.next_sibling_id;
            widget.hierarchy.next_sibling_id = STBG_WIDGET_ID_NULL;

            // Add to the hash table
            widget.hash = hash;
            ref var bucket = ref stbg__get_hash_entry_by_hash(hash);

            if (bucket.first_widget_in_bucket != STBG_WIDGET_ID_NULL)
            {
                // Bucket already points to an existing widget, make that widget point back to us since the first
                // element in the bucket is going to be us.
                stbg_get_widget_by_id(bucket.first_widget_in_bucket).hash_chain.prev_same_bucket = widget.id;
                widget.hash_chain.next_same_bucket = bucket.first_widget_in_bucket;
            }
            bucket.first_widget_in_bucket = widget.id;
        }
        else
        {
            // Reused widget!
            context.frame_stats.reused_widgets++;
        }

        // Update last used
        if (widget.last_used_in_frame == context.current_frame)
        {
            context.frame_stats.duplicated_widgets_ids++;
            // Duplicated widget identifier found.. trigger exptected behaviour
            switch (context.init_options.duplicated_widget_identifier_behaviour)
            {
                case STBG_DUP_ID_BEHAVIOUR.ASSERT:
                    Debug.Assert(widget.last_used_in_frame != context.current_frame, "Duplicated widget identifier!!");
                    break;
                case STBG_DUP_ID_BEHAVIOUR.EXCEPTION:
                    throw new Exception("Duplicated widget identifier!!");
                case STBG_DUP_ID_BEHAVIOUR.CONSOLE:
                    Console.Error.WriteLine("Duplicated widget identifier!!");
                    break;
                case STBG_DUP_ID_BEHAVIOUR.NONE:
                    break;
            }

        }
        widget.last_used_in_frame = context.current_frame;

        // Update hierarchy
        widget.hierarchy = new stbg_widget_hierarchy();
        widget.hierarchy.parent_id = context.current_widget_id;
        if (widget.hierarchy.parent_id != STBG_WIDGET_ID_NULL)
        {
            // If we have a parent:
            // - Update the list of children of our parent
            // - Update the list of siblings of any children
            ref var parent = ref stbg_get_widget_by_id(widget.hierarchy.parent_id);

            if (parent.hierarchy.last_children_id != STBG_WIDGET_ID_NULL)
            {
                // Parent already has children:
                // - set ourselves as the next sibling to the last children
                // - set our previous sibling to the last children
                // - replace the last children with ourselves
                stbg_get_widget_by_id(parent.hierarchy.last_children_id).hierarchy.next_sibling_id = widget.id;
                widget.hierarchy.prev_sibling_id = parent.hierarchy.last_children_id;
                parent.hierarchy.last_children_id = widget.id;
            }
            else
            {
                // Parent has no children, so we are the first and last children of our parent
                parent.hierarchy.first_children_id = parent.hierarchy.last_children_id = widget.id;
            }
        }

        return ref widget;
    }


    private static void stbg__remove_widget(ref stbg_widget widget)
    {
        Debug.Assert(!context.inside_frame);
        Debug.Assert((widget.flags & STBG_WIDGET_FLAGS.USED) != 0);
        Debug.Assert(widget.last_used_in_frame != context.current_frame);

        // Reset hierarchy
        widget.hierarchy = new stbg_widget_hierarchy();

        // Reset flags
        widget.flags = STBG_WIDGET_FLAGS.NONE;

        // Remove from the hash table
        if (widget.hash_chain.prev_same_bucket == STBG_WIDGET_ID_NULL)
        {
            // We are the first element in the bucket, make it point to the next element in our hash list
            ref var bucket = ref stbg__get_hash_entry_by_hash(widget.hash);

            Debug.Assert(bucket.first_widget_in_bucket == widget.id);

            bucket.first_widget_in_bucket = widget.hash_chain.next_same_bucket;
        }
        else
        {
            // We are NOT the first element, make the previous entry point to the next one in our hash list
            stbg_get_widget_by_id(widget.hash_chain.prev_same_bucket).hash_chain.next_same_bucket = widget.hash_chain.next_same_bucket;
        }

        widget.hash_chain = new stbg_widget_hash_chain();
        widget.hash = 0;

        // Update the next free widget id        
        widget.hierarchy.next_sibling_id = context.first_free_widget_id;
        context.first_free_widget_id = widget.id;

        context.frame_stats.destroyed_widgets++;
    }

    private static bool stbg__find_widget_by_hash(widget_hash hash, out widget_id foundId)
    {
        ref var bucket = ref stbg__get_hash_entry_by_hash(hash);

        if (bucket.first_widget_in_bucket != STBG_WIDGET_ID_NULL)
        {
            foundId = bucket.first_widget_in_bucket;

            do
            {
                ref var widget = ref stbg_get_widget_by_id(foundId);

                if (widget.hash == hash)
                    return true;

                foundId = widget.hash_chain.next_same_bucket;

            } while (foundId != STBG_WIDGET_ID_NULL);
        }

        foundId = STBG_WIDGET_ID_NULL;
        return false;
    }

    private static ref stbg_hash_entry stbg__get_hash_entry_by_hash(widget_hash hash)
    {
        int index = Math.Abs(hash % context.widgets.Length);
        return ref context.hash_table[index];
    }

    private static widget_hash stbg__calculate_hash(STBG_WIDGET_TYPE type, string identifier)
    {
        Span<byte> key = stackalloc byte[sizeof(long)];
        Span<byte> output = stackalloc byte[sizeof(widget_hash)];

        if (context.current_widget_id == STBG_WIDGET_ID_NULL)
        {
            BitConverter.TryWriteBytes(key, 0x1234567890123456UL);
        }
        else
        {
            var parent_hash = stbg_get_widget_by_id(context.current_widget_id).hash;

            BitConverter.TryWriteBytes(key, parent_hash);
            BitConverter.TryWriteBytes(key.Slice(sizeof(widget_hash)), parent_hash);
        }

        key[0] += (byte)type; //Include the type of as part of the key, so changing the type produces a different hash

        var identifierAsBytes = MemoryMarshal.Cast<char, byte>(identifier.AsSpan());

        StbHash.stbh_halfsiphash(identifierAsBytes, key, output);

        widget_hash outputHash = BitConverter.ToInt32(output);

        return outputHash;
    }
}
